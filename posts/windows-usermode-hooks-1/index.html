<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Windows usermode hooks - Part 1 - Detection" /><meta property="og:locale" content="en" /><meta name="description" content="This post will guide you through how to detect usermode hooks in Windows default libraries and APIs, regardless of whether they have been inserted by AV/EDR products or other third-party software." /><meta property="og:description" content="This post will guide you through how to detect usermode hooks in Windows default libraries and APIs, regardless of whether they have been inserted by AV/EDR products or other third-party software." /><link rel="canonical" href="https://st4ckh0und.github.io/posts/windows-usermode-hooks-1/" /><meta property="og:url" content="https://st4ckh0und.github.io/posts/windows-usermode-hooks-1/" /><meta property="og:site_name" content="st4ckh0und" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-05-25T14:15:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Windows usermode hooks - Part 1 - Detection" /><meta name="twitter:site" content="@st4ckh0und" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-05-25T14:22:06+02:00","datePublished":"2022-05-25T14:15:00+02:00","description":"This post will guide you through how to detect usermode hooks in Windows default libraries and APIs, regardless of whether they have been inserted by AV/EDR products or other third-party software.","headline":"Windows usermode hooks - Part 1 - Detection","mainEntityOfPage":{"@type":"WebPage","@id":"https://st4ckh0und.github.io/posts/windows-usermode-hooks-1/"},"url":"https://st4ckh0und.github.io/posts/windows-usermode-hooks-1/"}</script><title>Windows usermode hooks - Part 1 - Detection | st4ckh0und</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="st4ckh0und"><meta name="application-name" content="st4ckh0und"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/img/avatar.jpg " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">st4ckh0und</a></div><div class="site-subtitle font-italic">A blog about cyber security</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/st4ckh0und" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/st4ckh0und" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['contact','stackhound.me'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Windows usermode hooks - Part 1 - Detection</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Windows usermode hooks - Part 1 - Detection</h1><div class="post-meta text-muted"><div> By <em> <a href="https://twitter.com/st4ckh0und">Valdemar Car√∏e</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1653480900" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-05-25 </em> </span> <span> Updated <em class="timeago" data-ts="1653481326" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-05-25 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2654 words"> <em>14 min</em> read</span></div></div></div><div class="post-content"><p>This post will guide you through how to detect usermode hooks in Windows default libraries and APIs, regardless of whether they have been inserted by AV/EDR products or other third-party software.</p><h2 id="introduction"><span class="mr-2">Introduction</span><a href="#introduction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>It is a well-known phenomena that AV/EDR products or software with similar intent, such as anti-cheat products for games, utilize usermode hooking techniques to monitor the usage of vital APIs in the Windows default libraries. A hook can be designed in a variety of ways, but most commonly, they are designed as filters for specific Windows APIs that are commonly used for malicious purposes. By redirecting the flow of a function through a detour function, the parameters of the function can be analysed before deciding whether to continue execution of the original function or whether to deny access to the original function and returning to the caller.</p><p>An example of a vital Windows API that most AV/EDR products monitor is the <code class="language-plaintext highlighter-rouge">NtCreateThreadEx</code> function.</p><p><img data-src="/assets/img/2022-05-25-windows-usermode-hooks-1/NtCreateThreadEx_1.png" alt="NtCreateThreadEx1" data-proofer-ignore></p><p>As can be seen in the illustration above, the function is a wrapper for a syscall into the kernel. This particular function is responsible for spawning a new thread in the context of a process, and is often used by malicious actors to execute buffers containing shellcode. An example of the same API when hooked by an AV/EDR product (in this case, SentinelOne) can be seen below.</p><p><img data-src="/assets/img/2022-05-25-windows-usermode-hooks-1/NtCreateThreadEx_2.png" alt="NtCreateThreadEx2" data-proofer-ignore></p><p>Notice how the first instructions in the function has been replaced with a relative <code class="language-plaintext highlighter-rouge">jmp</code> instruction that redirects the execution flow into a function located in the <code class="language-plaintext highlighter-rouge">InProcessClient64.dll</code> library. Here, the SentinelOne library can analyse the parameters of the function in an attempt to evaluate whether the function is being used for malicious purposes. If the library evaluates that the usage is legitimate, they will continue execution of the <code class="language-plaintext highlighter-rouge">NtCreateThreadEx</code> function. However, if the library evaluates that the usage is malicious, the process will terminate and a security incident event will be raised.</p><h2 id="enumerating-modules"><span class="mr-2">Enumerating modules</span><a href="#enumerating-modules" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Most AV/EDR products and similar software only target Windows APIs, which can be located by function name in the Windows default libraries, <code class="language-plaintext highlighter-rouge">kernel32.dll</code>, <code class="language-plaintext highlighter-rouge">kernelbase.dll</code> and <code class="language-plaintext highlighter-rouge">ntdll.dll</code>. However, before we can locate these functions, we must first locate their libraries in memory.</p><p>When a library is loaded by a Windows process, an entry for the library is inserted into a doubly linked list in the so-called <code class="language-plaintext highlighter-rouge">ProcessEnvironmentBlock</code> (<code class="language-plaintext highlighter-rouge">PEB</code>). We can iterate this list as shown below.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="n">PEB</span><span class="o">*</span> <span class="n">peb</span> <span class="o">=</span> <span class="n">NtCurrentTeb</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ProcessEnvironmentBlock</span><span class="p">;</span>

<span class="n">LIST_ENTRY</span><span class="o">*</span> <span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">peb</span><span class="o">-&gt;</span><span class="n">Ldr</span><span class="o">-&gt;</span><span class="n">InMemoryOrderModuleList</span><span class="p">;</span>
<span class="n">LIST_ENTRY</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">Flink</span><span class="p">;</span>

<span class="k">while</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">LDR_DATA_TABLE_ENTRY</span><span class="o">*</span> <span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="n">LDR_DATA_TABLE_ENTRY</span><span class="o">*</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">next</span> <span class="o">-</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">LDR_DATA_TABLE_ENTRY</span><span class="p">,</span> <span class="n">InMemoryOrderLinks</span><span class="p">));</span>

    <span class="n">UNICODE_STRING</span><span class="o">*</span> <span class="n">fullname</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">FullDllName</span><span class="p">;</span>
    <span class="n">UNICODE_STRING</span><span class="o">*</span> <span class="n">basename</span> <span class="o">=</span> <span class="p">(</span><span class="n">UNICODE_STRING</span><span class="o">*</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">fullname</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">UNICODE_STRING</span><span class="p">));</span>

    <span class="c1">// Perform enumeration of the individual library here</span>
    <span class="c1">// The library address in memory is given by entry-&gt;DllBase</span>

    <span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">Flink</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="enumerating-exports"><span class="mr-2">Enumerating exports</span><a href="#enumerating-exports" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Once we have located the libraries in memory, we are ready to enumerate their export directory and thereby locate all the functions that they are promoting by name. It is obviously entirely possible to hook unnamed internal functions, but they are harder to locate as they are not being promoted by the libraries themselves, and for that reason, they are usually untouched by AV/EDR products.</p><p>In order to enumerate the export directory of the library, we must first understand the PE file format. The PE file format starts with a DOS header, which contains the offset of the subsequent PE header (also called the NT header). Inside the PE header is a <code class="language-plaintext highlighter-rouge">DataDirectory</code> array, which contains entries that points to various important tables, such as the export table, the import table, the relocation table, etc.</p><p>An exported function can be located by two different attributes, either by its name or by its ordinal (function number). We are specifically interested in the export directory of the PE header, which contains a variety of information, including the relative virtual addresses (RVAs) of the following tables:</p><ul><li>The function table, which contains the addresses of all exported functions sorted by their ordinal.<li>The name table, which contains the addresses of all exported names sorted in ascending order.<li>The name ordinal table, which contains the ordinals of all exported names sorted in ascending order.</ul><p>We can consider the name ordinal table a mapping between the name table and the function table. Once we have located an entry in the name table by index, we can access that same index in the name ordinal table to obtain the function ordinal for the given function name. This ordinal can then be used to locate the equivalent entry in the function table by index, and thereby obtaining the address of the named function.</p><p>We can perform all of these steps as shown below.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="n">IMAGE_DOS_HEADER</span><span class="o">*</span> <span class="n">dos</span> <span class="o">=</span> <span class="p">(</span><span class="n">IMAGE_DOS_HEADER</span><span class="o">*</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">DllBase</span><span class="p">;</span>
<span class="n">IMAGE_NT_HEADERS</span><span class="o">*</span> <span class="n">nt</span> <span class="o">=</span> <span class="p">(</span><span class="n">IMAGE_NT_HEADERS</span><span class="o">*</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">DllBase</span> <span class="o">+</span> <span class="n">dos</span><span class="o">-&gt;</span><span class="n">e_lfanew</span><span class="p">);</span>

<span class="n">IMAGE_EXPORT_DIRECTORY</span><span class="o">*</span> <span class="n">exports</span> <span class="o">=</span> <span class="p">(</span><span class="n">IMAGE_EXPORT_DIRECTORY</span><span class="o">*</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">DllBase</span> <span class="o">+</span> <span class="n">nt</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">DataDirectory</span><span class="p">[</span><span class="n">IMAGE_DIRECTORY_ENTRY_EXPORT</span><span class="p">].</span><span class="n">VirtualAddress</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">exports</span><span class="o">-&gt;</span><span class="n">AddressOfNames</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">WORD</span><span class="o">*</span> <span class="n">ordinals</span> <span class="o">=</span> <span class="p">(</span><span class="n">WORD</span><span class="o">*</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">DllBase</span> <span class="o">+</span> <span class="n">exports</span><span class="o">-&gt;</span><span class="n">AddressOfNameOrdinals</span><span class="p">);</span>
    <span class="n">DWORD</span><span class="o">*</span> <span class="n">names</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD</span><span class="o">*</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">DllBase</span> <span class="o">+</span> <span class="n">exports</span><span class="o">-&gt;</span><span class="n">AddressOfNames</span><span class="p">);</span>
    <span class="n">DWORD</span><span class="o">*</span> <span class="n">functions</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD</span><span class="o">*</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">DllBase</span> <span class="o">+</span> <span class="n">exports</span><span class="o">-&gt;</span><span class="n">AddressOfFunctions</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">exports</span><span class="o">-&gt;</span><span class="n">NumberOfNames</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">char</span><span class="o">*</span> <span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">DllBase</span> <span class="o">+</span> <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="kt">void</span><span class="o">*</span> <span class="n">function</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">DllBase</span> <span class="o">+</span> <span class="n">functions</span><span class="p">[</span><span class="n">ordinals</span><span class="p">[</span><span class="n">i</span><span class="p">]]);</span>

        <span class="c1">// Perform actions using the function name and address</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Interestingly, despite the fact that the export directory is inherently made for exporting functions from Dynamic-Link Libraries (DLLs), it is also possible to export constants and/or objects. Since we are looking for usermode hooks in the code section of a library, we are not interested in data objects or constants, especially since these are subject to modification, and will potentially yield false-positives when we test for hooks by comparing exports to their original variants on disk.</p><p>We can guard our enumeration against checking data objects by verifying that all of our target function addresses fall within the code region of the library. The relative virtual address (RVA) and region size of the code section of a library can be found in the PE header as shown below.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">function</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">DllBase</span> <span class="o">+</span> <span class="n">nt</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">BaseOfCode</span> <span class="o">&amp;&amp;</span>
    <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">function</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">DllBase</span> <span class="o">+</span> <span class="n">nt</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">BaseOfCode</span> <span class="o">+</span> <span class="n">nt</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">SizeOfCode</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Perform actions using the function name and address</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="loading-knowndlls"><span class="mr-2">Loading KnownDLLs</span><a href="#loading-knowndlls" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>The next step is to compare the bytes of each exported function against their original unmodified versions. Ideally, we would load the respective library from disk and compare against the bytes at a given offset. Unfortunately, this produces a range of false-positives as the library on disk has not been properly set up and has not had its relocations fixed. Instead of holding on to this crude technique, we will instead analyse how these libraries are initially loaded by the Windows loader and attempt to load a fresh copy using identical functions.</p><p>When we load a library using the <code class="language-plaintext highlighter-rouge">LoadLibrary</code> Windows API, a range of subsequent calls occur. For example, <code class="language-plaintext highlighter-rouge">LoadLibrary</code> invokes <code class="language-plaintext highlighter-rouge">LoadLibraryEx</code>, which invokes <code class="language-plaintext highlighter-rouge">LdrLoadDll</code>, which invokes a deeper nested internal function, and the list goes ever on. If we follow this chain of subsequent invocations, we arrive at a function called <code class="language-plaintext highlighter-rouge">LdrpLoadKnownDll</code> as seen in the call chain below.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>LoadLibrary
|-&gt; LoadLibraryEx
|--&gt; LdrLoadDll
|---&gt; LdrpLoadDll
|----&gt; LdrpLoadDllInternal
|-----&gt; LdrpFindOrPrepareLoadingModule
|------&gt; LdrpLoadKnownDll
</pre></table></code></div></div><p>The <code class="language-plaintext highlighter-rouge">LdrpLoadKnownDll</code> function is responsible for loading KnownDLL libraries, which includes <code class="language-plaintext highlighter-rouge">kernel32.dll</code> and <code class="language-plaintext highlighter-rouge">kernelbase.dll</code>. The functionality of the <code class="language-plaintext highlighter-rouge">LdrpLoadKnownDll</code> function can be seen below.</p><p><img data-src="/assets/img/2022-05-25-windows-usermode-hooks-1/LdrpLoadKnownDll.png" alt="LdrpLoadKnownDll" data-proofer-ignore></p><p>The <code class="language-plaintext highlighter-rouge">LdrpLoadKnownDll</code> function appears to obtain a section handle to a KnownDLL library by invoking <code class="language-plaintext highlighter-rouge">LdrpFindKnownDll</code>, and then maps the library into memory by passing the section handle to <code class="language-plaintext highlighter-rouge">LdrpMapDllWithSectionHandle</code>. Let us take a look at how this section handle is obtained in the <code class="language-plaintext highlighter-rouge">LdrpFindKnownDll</code> function.</p><p><img data-src="/assets/img/2022-05-25-windows-usermode-hooks-1/LdrpFindKnownDll.png" alt="LdrpFindKnownDll" data-proofer-ignore></p><p>The <code class="language-plaintext highlighter-rouge">LdrpFindKnownDll</code> function obtains a section handle to a target KnownDLL library by invoking the <code class="language-plaintext highlighter-rouge">NtOpenSection</code> API with an <code class="language-plaintext highlighter-rouge">OBJECT_ATTRIBUTES</code> object whose <code class="language-plaintext highlighter-rouge">RootDirectory</code> attribute is set using an internal <code class="language-plaintext highlighter-rouge">LdrpKnownDllDirectoryHandle</code> object. Let us take a look at how this section handle is used to map the library into memory in the <code class="language-plaintext highlighter-rouge">LdrpMapDllWithSectionHandle</code> function.</p><p><img data-src="/assets/img/2022-05-25-windows-usermode-hooks-1/LdrpMapDllWithSectionHandle.png" alt="LdrpMapDllWithSectionHandle" data-proofer-ignore></p><p>The <code class="language-plaintext highlighter-rouge">LdrpMapDllWithSectionHandle</code> function invokes <code class="language-plaintext highlighter-rouge">LdrpMinimalMapModule</code> to map the library into memory, and then performs a subsequent series of actions to prepare the module for execution, such as populating the Import Address Table (IAT). Let us take a look at how the <code class="language-plaintext highlighter-rouge">LdrpMinimalMapModule</code> function works internally.</p><p><img data-src="/assets/img/2022-05-25-windows-usermode-hooks-1/LdrpMinimalMapModule.png" alt="LdrpMinimalMapModule" data-proofer-ignore></p><p>The <code class="language-plaintext highlighter-rouge">LdrpMinimalMapModule</code> function map the library into memory by invoking the <code class="language-plaintext highlighter-rouge">NtMapViewOfSection</code> API with the section handle previously obtained from the <code class="language-plaintext highlighter-rouge">NtOpenSection</code> API call in the <code class="language-plaintext highlighter-rouge">LdrpFindKnownDll</code> function.</p><p>We should be able to map our own KnownDLL library into memory by obtaining a section handle for the library using the <code class="language-plaintext highlighter-rouge">NtOpenSection</code> API and then mapping it into memory using the <code class="language-plaintext highlighter-rouge">NtMapViewOfSection</code> API. However, in order to do this, we must invoke the <code class="language-plaintext highlighter-rouge">NtOpenSection</code> API with a correctly configured <code class="language-plaintext highlighter-rouge">RootDirectory</code> handle similar to that of the internal <code class="language-plaintext highlighter-rouge">LdrpKnownDllDirectoryHandle</code> object.</p><p>In the 64-bit version of <code class="language-plaintext highlighter-rouge">ntdll.dll</code>, an exported function called <code class="language-plaintext highlighter-rouge">LdrGetKnownDllSectionHandle</code> does exactly what we are looking for. However, this function does not exist in the 32-bit version of <code class="language-plaintext highlighter-rouge">ntdll.dll</code> (or atleast the SYSWOW64 version), so we will have to create our own function. Let us take a look at how the <code class="language-plaintext highlighter-rouge">LdrGetKnownDllSectionHandle</code> object is constructed.</p><p><img data-src="/assets/img/2022-05-25-windows-usermode-hooks-1/LdrpInitializeProcess_1.png" alt="LdrpInitializeProcess1" data-proofer-ignore></p><p>The <code class="language-plaintext highlighter-rouge">LdrpInitializeProcess</code> function constructs the <code class="language-plaintext highlighter-rouge">LdrGetKnownDllSectionHandle</code> object by invoking the <code class="language-plaintext highlighter-rouge">NtOpenDirectoryObject</code> API with an <code class="language-plaintext highlighter-rouge">OBJECT_ATTRIBUTES</code> object whose <code class="language-plaintext highlighter-rouge">ObjectName</code> attribute is set to a <code class="language-plaintext highlighter-rouge">UNICODE_STRING</code> object that contains the string <code class="language-plaintext highlighter-rouge">"\KnownDlls"</code> as shown below.</p><p><img data-src="/assets/img/2022-05-25-windows-usermode-hooks-1/LdrpInitializeProcess_2.png" alt="LdrpInitializeProcess2" data-proofer-ignore></p><p>If we check the same functionality in the SYSWOW64 version of <code class="language-plaintext highlighter-rouge">ntdll.dll</code>, we observe the same thing, except the <code class="language-plaintext highlighter-rouge">UNICODE_STRING</code> object contains the string <code class="language-plaintext highlighter-rouge">"\KnownDlls32"</code> instead.</p><p><img data-src="/assets/img/2022-05-25-windows-usermode-hooks-1/LdrpInitializeProcess_3.png" alt="LdrpInitializeProcess3" data-proofer-ignore></p><p>If we puzzle all of our findings together, we find that we can construct our own <code class="language-plaintext highlighter-rouge">LdrGetKnownDllSectionHandle</code> function as shown below.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="cp">#pragma comment(lib, "ntdll")
</span>
<span class="k">extern</span> <span class="n">NTSTATUS</span> <span class="n">NTAPI</span> <span class="nf">RtlInitUnicodeStringEx</span><span class="p">(</span><span class="n">PUNICODE_STRING</span> <span class="n">DestinationString</span><span class="p">,</span> <span class="n">PWSTR</span> <span class="n">SourceString</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">NTSTATUS</span> <span class="n">NTAPI</span> <span class="nf">NtOpenDirectoryObject</span><span class="p">(</span><span class="n">PHANDLE</span> <span class="n">DirectoryHandle</span><span class="p">,</span> <span class="n">ACCESS_MASK</span> <span class="n">DesiredAccess</span><span class="p">,</span> <span class="n">POBJECT_ATTRIBUTES</span> <span class="n">ObjectAttributes</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">NTSTATUS</span> <span class="n">NTAPI</span> <span class="nf">NtOpenSection</span><span class="p">(</span><span class="n">PHANDLE</span> <span class="n">SectionHandle</span><span class="p">,</span> <span class="n">ACCESS_MASK</span> <span class="n">DesiredAccess</span><span class="p">,</span> <span class="n">POBJECT_ATTRIBUTES</span> <span class="n">ObjectAttributes</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">NTSTATUS</span> <span class="n">NTAPI</span> <span class="nf">NtClose</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">Handle</span><span class="p">);</span>

<span class="n">BOOL</span> <span class="nf">LdrGetKnownDllSectionHandle</span><span class="p">(</span><span class="n">LPWSTR</span> <span class="n">DllName</span><span class="p">,</span> <span class="n">PHANDLE</span> <span class="n">SectionHandle</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BOOL</span> <span class="n">Result</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

    <span class="n">UNICODE_STRING</span> <span class="n">KnownDllName</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

<span class="cp">#ifdef _WIN64
</span>    <span class="n">RtlInitUnicodeStringEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">KnownDllName</span><span class="p">,</span> <span class="s">L"</span><span class="se">\\</span><span class="s">KnownDlls"</span><span class="p">);</span>
<span class="cp">#else
</span>    <span class="n">RtlInitUnicodeStringEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">KnownDllName</span><span class="p">,</span> <span class="s">L"</span><span class="se">\\</span><span class="s">KnownDlls32"</span><span class="p">);</span>
<span class="cp">#endif
</span>    
    <span class="n">OBJECT_ATTRIBUTES</span> <span class="n">KnownDllAttributes</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">InitializeObjectAttributes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">KnownDllAttributes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">KnownDllName</span><span class="p">,</span> <span class="n">OBJ_CASE_INSENSITIVE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="n">HANDLE</span> <span class="n">KnownDllDirectoryHandle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">NT_SUCCESS</span><span class="p">(</span><span class="n">NtOpenDirectoryObject</span><span class="p">(</span><span class="o">&amp;</span><span class="n">KnownDllDirectoryHandle</span><span class="p">,</span> <span class="n">DIRECTORY_TRAVERSE</span> <span class="o">|</span> <span class="n">DIRECTORY_QUERY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">KnownDllAttributes</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">KnownDllDirectoryHandle</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">UNICODE_STRING</span> <span class="n">SectionName</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">NT_SUCCESS</span><span class="p">(</span><span class="n">RtlInitUnicodeStringEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SectionName</span><span class="p">,</span> <span class="n">DllName</span><span class="p">)))</span>
        <span class="p">{</span>
            <span class="n">OBJECT_ATTRIBUTES</span> <span class="n">SectionAttributes</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
            <span class="n">InitializeObjectAttributes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SectionAttributes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">SectionName</span><span class="p">,</span> <span class="n">OBJ_CASE_INSENSITIVE</span><span class="p">,</span> <span class="n">KnownDllDirectoryHandle</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">NT_SUCCESS</span><span class="p">(</span><span class="n">NtOpenSection</span><span class="p">(</span><span class="n">SectionHandle</span><span class="p">,</span> <span class="n">SECTION_MAP_EXECUTE</span> <span class="o">|</span> <span class="n">SECTION_MAP_READ</span> <span class="o">|</span> <span class="n">SECTION_QUERY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">SectionAttributes</span><span class="p">)))</span>
                <span class="n">Result</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">NtClose</span><span class="p">(</span><span class="n">KnownDllDirectoryHandle</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="detecting-hooks"><span class="mr-2">Detecting hooks</span><a href="#detecting-hooks" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>We can use the <code class="language-plaintext highlighter-rouge">LdrGetKnownDllSectionHandle</code> function to obtain a section handle for a KnownDLL library, which we can then map into memory using the <code class="language-plaintext highlighter-rouge">NtMapViewOfSection</code> API as shown below.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="cp">#pragma comment(lib, "ntdll")
</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="n">_SECTION_INHERIT</span>
<span class="p">{</span>
    <span class="n">ViewShare</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">ViewUnmap</span> <span class="o">=</span> <span class="mi">2</span>
<span class="p">}</span> <span class="n">SECTION_INHERIT</span><span class="p">,</span> <span class="o">*</span><span class="n">PSECTION_INHERIT</span><span class="p">;</span>

<span class="k">extern</span> <span class="n">NTSTATUS</span> <span class="n">NTAPI</span> <span class="nf">LdrGetKnownDllSectionHandle</span><span class="p">(</span><span class="n">LPCWSTR</span> <span class="n">DllName</span><span class="p">,</span> <span class="n">BOOLEAN</span> <span class="n">KnownDlls32</span><span class="p">,</span> <span class="n">PHANDLE</span> <span class="n">Section</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">NTSTATUS</span> <span class="n">NTAPI</span> <span class="nf">NtMapViewOfSection</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">SectionHandle</span><span class="p">,</span> <span class="n">HANDLE</span> <span class="n">ProcessHandle</span><span class="p">,</span> <span class="n">PVOID</span> <span class="n">BaseAddress</span><span class="p">,</span> <span class="n">ULONG_PTR</span> <span class="n">ZeroBits</span><span class="p">,</span> <span class="n">SIZE_T</span> <span class="n">CommitSize</span><span class="p">,</span> <span class="n">PLARGE_INTEGER</span> <span class="n">SectionOffset</span><span class="p">,</span> <span class="n">PSIZE_T</span> <span class="n">ViewSize</span><span class="p">,</span> <span class="n">SECTION_INHERIT</span> <span class="n">InheritDisposition</span><span class="p">,</span> <span class="n">ULONG</span> <span class="n">AllocationType</span><span class="p">,</span> <span class="n">ULONG</span> <span class="n">Win32Protect</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">NTSTATUS</span> <span class="n">NTAPI</span> <span class="nf">NtClose</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">Handle</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">LoadKnownDll</span><span class="p">(</span><span class="n">LPCWSTR</span> <span class="n">lpModuleName</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">hSection</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">LdrGetKnownDllSectionHandle</span><span class="p">(</span><span class="n">lpModuleName</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hSection</span><span class="p">);</span>

    <span class="n">PVOID</span> <span class="n">pvBase</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">SIZE_T</span> <span class="n">stSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">NtMapViewOfSection</span><span class="p">(</span><span class="n">hSection</span><span class="p">,</span> <span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">pvBase</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stSize</span><span class="p">,</span> <span class="n">ViewUnmap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_READONLY</span><span class="p">)</span>

    <span class="n">NtClose</span><span class="p">(</span><span class="n">hSection</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The mapped library should correspond to our target library prior to having hooks installed by AV/EDR products or similar software, and we can use this as a basis for detecting anomalous bytes in exported functions of the original library.</p><p>Since the original library and the mapped library are identical, the offset of exported functions are also the same. In order to locate an exported function in the mapped library, we can obtain its offset by subtracting the base address of the original library, and then add this offset to the base address of the mapped library.</p><p>Finally, we need to decide on limitations, such as how many bytes are checked per function. If we decide to check too many bytes per function, we might over-reach into a subsequent function in memory. When this happens, we risk false-positives about a function having been modified, when in fact it is an adjacent function that has been modified.</p><p>A relative <code class="language-plaintext highlighter-rouge">jmp</code> instruction, such as the one used by SentinelOne, consists of a 5 byte sequence. Since hooks are usually inserted at the start of a function, we can assume that a 5 byte limit is adequate for our purposes.</p><p>Now that we have gone through every step of the detection phase, we can puzzle our code pieces together and construct the following full sample.</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;winternl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="cp">#pragma comment(lib, "ntdll")
</span>
<span class="cp">#define DIRECTORY_QUERY        0x0001
#define DIRECTORY_TRAVERSE    0x0002
</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="n">_SECTION_INHERIT</span> <span class="p">{</span>
    <span class="n">ViewShare</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">ViewUnmap</span><span class="o">=</span><span class="mi">2</span>
<span class="p">}</span> <span class="n">SECTION_INHERIT</span><span class="p">,</span> <span class="o">*</span><span class="n">PSECTION_INHERIT</span><span class="p">;</span>

<span class="k">extern</span> <span class="n">NTSTATUS</span> <span class="n">NTAPI</span> <span class="nf">NtClose</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">Handle</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">NTSTATUS</span> <span class="n">NTAPI</span> <span class="nf">NtOpenDirectoryObject</span><span class="p">(</span><span class="n">PHANDLE</span> <span class="n">DirectoryHandle</span><span class="p">,</span> <span class="n">ACCESS_MASK</span> <span class="n">DesiredAccess</span><span class="p">,</span> <span class="n">POBJECT_ATTRIBUTES</span> <span class="n">ObjectAttributes</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">NTSTATUS</span> <span class="n">NTAPI</span> <span class="nf">NtOpenSection</span><span class="p">(</span><span class="n">PHANDLE</span> <span class="n">SectionHandle</span><span class="p">,</span> <span class="n">ACCESS_MASK</span> <span class="n">DesiredAccess</span><span class="p">,</span> <span class="n">POBJECT_ATTRIBUTES</span> <span class="n">ObjectAttributes</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">NTSTATUS</span> <span class="n">NTAPI</span> <span class="nf">NtMapViewOfSection</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">SectionHandle</span><span class="p">,</span> <span class="n">HANDLE</span> <span class="n">ProcessHandle</span><span class="p">,</span> <span class="n">PVOID</span><span class="o">*</span> <span class="n">BaseAddress</span><span class="p">,</span> <span class="n">ULONG</span> <span class="n">ZeroBits</span><span class="p">,</span> <span class="n">SIZE_T</span> <span class="n">CommitSize</span><span class="p">,</span> <span class="n">PLARGE_INTEGER</span> <span class="n">SectionOffset</span><span class="p">,</span> <span class="n">PSIZE_T</span> <span class="n">ViewSize</span><span class="p">,</span> <span class="n">SECTION_INHERIT</span> <span class="n">InheritDisposition</span><span class="p">,</span> <span class="n">ULONG</span> <span class="n">AllocationType</span><span class="p">,</span> <span class="n">ULONG</span> <span class="n">Protect</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">NTSTATUS</span> <span class="n">NTAPI</span> <span class="nf">NtUnmapViewOfSection</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">ProcessHandle</span><span class="p">,</span> <span class="n">PVOID</span> <span class="n">BaseAddress</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">NTSTATUS</span> <span class="n">NTAPI</span> <span class="nf">RtlInitUnicodeStringEx</span><span class="p">(</span><span class="n">PUNICODE_STRING</span> <span class="n">DestinationString</span><span class="p">,</span> <span class="n">PCWSTR</span> <span class="n">SourceString</span><span class="p">);</span>

<span class="n">BOOL</span> <span class="nf">LdrGetKnownDllSectionHandle</span><span class="p">(</span><span class="n">LPCWSTR</span> <span class="n">DllName</span><span class="p">,</span> <span class="n">PHANDLE</span> <span class="n">SectionHandle</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BOOL</span> <span class="n">Result</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

    <span class="n">UNICODE_STRING</span> <span class="n">KnownDllName</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

<span class="cp">#ifdef _WIN64
</span>    <span class="n">RtlInitUnicodeStringEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">KnownDllName</span><span class="p">,</span> <span class="s">L"</span><span class="se">\\</span><span class="s">KnownDlls"</span><span class="p">);</span>
<span class="cp">#else
</span>    <span class="n">RtlInitUnicodeStringEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">KnownDllName</span><span class="p">,</span> <span class="s">L"</span><span class="se">\\</span><span class="s">KnownDlls32"</span><span class="p">);</span>
<span class="cp">#endif
</span>    
    <span class="n">OBJECT_ATTRIBUTES</span> <span class="n">KnownDllAttributes</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">InitializeObjectAttributes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">KnownDllAttributes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">KnownDllName</span><span class="p">,</span> <span class="n">OBJ_CASE_INSENSITIVE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="n">HANDLE</span> <span class="n">KnownDllDirectoryHandle</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">NT_SUCCESS</span><span class="p">(</span><span class="n">NtOpenDirectoryObject</span><span class="p">(</span><span class="o">&amp;</span><span class="n">KnownDllDirectoryHandle</span><span class="p">,</span> <span class="n">DIRECTORY_TRAVERSE</span> <span class="o">|</span> <span class="n">DIRECTORY_QUERY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">KnownDllAttributes</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">KnownDllDirectoryHandle</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">UNICODE_STRING</span> <span class="n">SectionName</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">NT_SUCCESS</span><span class="p">(</span><span class="n">RtlInitUnicodeStringEx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SectionName</span><span class="p">,</span> <span class="n">DllName</span><span class="p">)))</span>
        <span class="p">{</span>
            <span class="n">OBJECT_ATTRIBUTES</span> <span class="n">SectionAttributes</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
            <span class="n">InitializeObjectAttributes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SectionAttributes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">SectionName</span><span class="p">,</span> <span class="n">OBJ_CASE_INSENSITIVE</span><span class="p">,</span> <span class="n">KnownDllDirectoryHandle</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">NT_SUCCESS</span><span class="p">(</span><span class="n">NtOpenSection</span><span class="p">(</span><span class="n">SectionHandle</span><span class="p">,</span> <span class="n">SECTION_MAP_EXECUTE</span> <span class="o">|</span> <span class="n">SECTION_MAP_READ</span> <span class="o">|</span> <span class="n">SECTION_QUERY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">SectionAttributes</span><span class="p">)))</span>
                <span class="n">Result</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">NtClose</span><span class="p">(</span><span class="n">KnownDllDirectoryHandle</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">PEB</span><span class="o">*</span> <span class="n">peb</span> <span class="o">=</span> <span class="n">NtCurrentTeb</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ProcessEnvironmentBlock</span><span class="p">;</span>

    <span class="n">LIST_ENTRY</span><span class="o">*</span> <span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">peb</span><span class="o">-&gt;</span><span class="n">Ldr</span><span class="o">-&gt;</span><span class="n">InMemoryOrderModuleList</span><span class="p">;</span>
    <span class="n">LIST_ENTRY</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">Flink</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="n">head</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">LDR_DATA_TABLE_ENTRY</span><span class="o">*</span> <span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="n">LDR_DATA_TABLE_ENTRY</span><span class="o">*</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">next</span> <span class="o">-</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">LDR_DATA_TABLE_ENTRY</span><span class="p">,</span> <span class="n">InMemoryOrderLinks</span><span class="p">));</span>

        <span class="n">UNICODE_STRING</span><span class="o">*</span> <span class="n">fullname</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">FullDllName</span><span class="p">;</span>
        <span class="n">UNICODE_STRING</span><span class="o">*</span> <span class="n">basename</span> <span class="o">=</span> <span class="p">(</span><span class="n">UNICODE_STRING</span><span class="o">*</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">fullname</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">UNICODE_STRING</span><span class="p">));</span>

        <span class="n">IMAGE_DOS_HEADER</span><span class="o">*</span> <span class="n">dos</span> <span class="o">=</span> <span class="p">(</span><span class="n">IMAGE_DOS_HEADER</span><span class="o">*</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">DllBase</span><span class="p">;</span>
        <span class="n">IMAGE_NT_HEADERS</span><span class="o">*</span> <span class="n">nt</span> <span class="o">=</span> <span class="p">(</span><span class="n">IMAGE_NT_HEADERS</span><span class="o">*</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">DllBase</span> <span class="o">+</span> <span class="n">dos</span><span class="o">-&gt;</span><span class="n">e_lfanew</span><span class="p">);</span>

        <span class="n">IMAGE_EXPORT_DIRECTORY</span><span class="o">*</span> <span class="n">exports</span> <span class="o">=</span> <span class="p">(</span><span class="n">IMAGE_EXPORT_DIRECTORY</span><span class="o">*</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">DllBase</span> <span class="o">+</span> <span class="n">nt</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">DataDirectory</span><span class="p">[</span><span class="n">IMAGE_DIRECTORY_ENTRY_EXPORT</span><span class="p">].</span><span class="n">VirtualAddress</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">exports</span><span class="o">-&gt;</span><span class="n">AddressOfNames</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"Checking for hooks in %S</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">basename</span><span class="o">-&gt;</span><span class="n">Buffer</span><span class="p">);</span>

            <span class="n">HANDLE</span> <span class="n">section</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">LdrGetKnownDllSectionHandle</span><span class="p">(</span><span class="n">basename</span><span class="o">-&gt;</span><span class="n">Buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">section</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">PVOID</span> <span class="n">base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">SIZE_T</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">NT_SUCCESS</span><span class="p">(</span><span class="n">NtMapViewOfSection</span><span class="p">(</span><span class="n">section</span><span class="p">,</span> <span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">base</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="n">ViewUnmap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_READONLY</span><span class="p">)))</span>
                <span class="p">{</span>
                    <span class="n">WORD</span><span class="o">*</span> <span class="n">ordinals</span> <span class="o">=</span> <span class="p">(</span><span class="n">WORD</span><span class="o">*</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">DllBase</span> <span class="o">+</span> <span class="n">exports</span><span class="o">-&gt;</span><span class="n">AddressOfNameOrdinals</span><span class="p">);</span>
                    <span class="n">DWORD</span><span class="o">*</span> <span class="n">names</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD</span><span class="o">*</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">DllBase</span> <span class="o">+</span> <span class="n">exports</span><span class="o">-&gt;</span><span class="n">AddressOfNames</span><span class="p">);</span>
                    <span class="n">DWORD</span><span class="o">*</span> <span class="n">functions</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD</span><span class="o">*</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">DllBase</span> <span class="o">+</span> <span class="n">exports</span><span class="o">-&gt;</span><span class="n">AddressOfFunctions</span><span class="p">);</span>

                    <span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">exports</span><span class="o">-&gt;</span><span class="n">NumberOfNames</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="kt">char</span><span class="o">*</span> <span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">DllBase</span> <span class="o">+</span> <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                        <span class="kt">void</span><span class="o">*</span> <span class="n">function</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">DllBase</span> <span class="o">+</span> <span class="n">functions</span><span class="p">[</span><span class="n">ordinals</span><span class="p">[</span><span class="n">i</span><span class="p">]]);</span>

                        <span class="k">if</span> <span class="p">((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">function</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">DllBase</span> <span class="o">+</span> <span class="n">nt</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">BaseOfCode</span> <span class="o">&amp;&amp;</span>
                            <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">function</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">DllBase</span> <span class="o">+</span> <span class="n">nt</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">BaseOfCode</span> <span class="o">+</span> <span class="n">nt</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">SizeOfCode</span><span class="p">)</span>
                        <span class="p">{</span>
                            <span class="n">DWORD</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">function</span> <span class="o">-</span> <span class="p">(</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">DllBase</span><span class="p">);</span>
                            <span class="kt">void</span><span class="o">*</span> <span class="n">mapped</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)((</span><span class="n">PBYTE</span><span class="p">)</span><span class="n">base</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>

                            <span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">mapped</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                                <span class="n">printf</span><span class="p">(</span><span class="s">"Detected hook in %S!%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">basename</span><span class="o">-&gt;</span><span class="n">Buffer</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
                        <span class="p">}</span>
                    <span class="p">}</span>

                    <span class="n">NtUnmapViewOfSection</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="n">base</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="n">NtClose</span><span class="p">(</span><span class="n">section</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">Flink</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>In order to avoid being detected by AV/EDR products when using this tool, our techniques can be taken even further. For a demonstration of this, please visit <a href="https://github.com/st4ckh0und/hook-buster">the official project on GitHub</a>.</p><h2 id="conclusion"><span class="mr-2">Conclusion</span><a href="#conclusion" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Hope you enjoyed this blog post!</p><p>If you have any questions, feel free to reach out to me on <a href="https://github.com/st4ckh0und">GitHub</a> or <a href="https://twitter.com/st4ckh0und">Twitter</a>.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/redteam/'>Redteam</a>, <a href='/categories/av-edr/'>AV/EDR</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/av-edr/" class="post-tag no-text-decoration" >AV/EDR</a> <a href="/tags/malware/" class="post-tag no-text-decoration" >Malware</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Windows usermode hooks - Part 1 - Detection - st4ckh0und&amp;url=https://st4ckh0und.github.io/posts/windows-usermode-hooks-1/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://st4ckh0und.github.io/posts/windows-usermode-hooks-1/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/windows-usermode-hooks-1/">Windows usermode hooks - Part 1 - Detection</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/av-edr/">AV/EDR</a> <a class="post-tag" href="/tags/malware/">Malware</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div class="post-navigation d-flex justify-content-between"> <span class="btn btn-outline-primary disabled" prompt="Older"><p>-</p></span> <span class="btn btn-outline-primary disabled" prompt="Newer"><p>-</p></span></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> ¬© 2022 <a href="https://twitter.com/st4ckh0und">Valdemar Car√∏e</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/av-edr/">AV/EDR</a> <a class="post-tag" href="/tags/malware/">Malware</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
